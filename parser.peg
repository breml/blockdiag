{
// blockdiag parser

package blockdiag
}

diag = _ (diagtype:("blockdiag" / "diagram") {
	diag = Diag{}
	diag.Nodes = make(map[string]*Node)
	diag.Edges = make(map[string]*Edge)
	diag.Attributes = make(map[string]string)
	return diagtype, nil
} ) _ "{" _ diagElements* _ "}" _ EOF {
	updateEdges()
	diag.Name = "test"
	return diag, nil 
}

// diagElements = diagAttr / chain / node
diagElements = diagAttr / chains

diagAttr = attrName:ident _ "=" _ attrValue:attrValue _ ";" _ {
	diag.Attributes[attrName.(string)] = attrValue.(string)
	return nil, nil
}

attrValue = ([a-zA-Z0-9]+) {
	return string(c.text), nil
}

chains = chain+

chain = node:node _ nodes:(edge _ n:node _ {
	return n, nil
} )* ";" _ {
	nodeA := node.(*Node)
	
	for _, n := range toIfaceSlice(nodes) {
		nodeB := n.(*Node)
		edge := nodeA.Name + "|" + nodeB.Name
		
		if e, present := diag.Edges[edge]; !present {
			e = &Edge{Name: edge, Start: nodeA, End: nodeB}
			diag.Edges[edge] = e
		}
		nodeA = nodeB
	}
	return nil, nil
}

node = node:ident {
	var n *Node
	var present bool
	
	name := string(c.text)
	if n, present = diag.Nodes[name]; !present {
		n = &Node{Name: name}
		diag.Nodes[name] = n
	} 
	return n, nil
}

edge = edge:("->") 

ident = [a-zA-Z0-9_]+ {
	return string(c.text), nil
}

_ = ([ \t\n\r] / Comment)*

Comment = "#" [^\n\r]* [\r]?[\n]

EOF = !.
